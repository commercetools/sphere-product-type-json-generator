// Generated by CoffeeScript 1.9.3
(function() {
  var ATTRIBUTE_TYPES, MASTER_SKU_NAME, ProductTypeGenerator, Promise, _, fs;

  _ = require('underscore');

  _.mixin(require('underscore.string').exports());

  Promise = require('bluebird');

  fs = Promise.promisifyAll(require('fs'));

  ATTRIBUTE_TYPES = {
    text: 'text',
    ltext: 'ltext',
    "enum": 'enum',
    lenum: 'lenum',
    set: 'set',
    reference: 'reference',
    nested: 'nested'
  };

  MASTER_SKU_NAME = 'mastersku';


  /**
   * Class for generating JSON product-type representations from CSV files
   * @class ProductTypeGenerator
   */

  ProductTypeGenerator = (function() {
    function ProductTypeGenerator(client1) {
      this.client = client1;
    }


    /**
     * Main exposed function that runs the program
     * @param  {Array} types The parsed CSV records of product-types
     * @param  {Array} attributes The parsed CSV records of product-type attributes
     * @param  {String} target The path to the folder where to write files
     * @param  {Boolean} withRetailer Wheter to generate extra files for master<->retailer support
     * @return {Promise} A promise resolved with summary report
     */

    ProductTypeGenerator.prototype.run = function(types, attributes, target, withRetailer, client) {
      this.client = client;
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var attributeDefinitionMastersku, attributeDefinitions, e, productTypeDefinitions, productTypeDefinitionsRetailers;
          try {
            attributeDefinitions = _this._createAttributeDefinitions(attributes);
            productTypeDefinitions = _this._createProductTypesDefinitions(types, attributeDefinitions);
            if (withRetailer) {
              attributeDefinitionMastersku = _this._createAttributeDefinitionMastersku();
              productTypeDefinitionsRetailers = _this._createProductTypesDefinitions(types, attributeDefinitions, attributeDefinitionMastersku);
            }
            return resolve({
              productTypes: productTypeDefinitions,
              productTypesForRetailer: productTypeDefinitionsRetailers
            });
          } catch (_error) {
            e = _error;
            return reject(e);
          }
        };
      })(this));
    };


    /**
     * Map all attribute definitions in the correct format
     * @param  {Array} attributes The parsed CSV records of product-type attributes
     * @return {Object} A JSON object that maps attribute definitions in correct format using name as key
     */

    ProductTypeGenerator.prototype._createAttributeDefinitions = function(attributes) {
      var attrName, attributeDefinition, attributeDefinitions, i, lastProcessedAttributeDefinition, len, row;
      attributeDefinitions = {};
      lastProcessedAttributeDefinition = null;
      for (i = 0, len = attributes.length; i < len; i++) {
        row = attributes[i];
        attrName = row['name'];
        if (!!attrName) {
          attributeDefinition = {
            name: attrName,
            label: this._i18n(row, 'label'),
            type: {
              name: this._type(row['type'])
            },
            attributeConstraint: row['attributeConstraint'],
            isRequired: row['isRequired'] === 'true',
            isSearchable: row['isSearchable'] === 'true'
          };
          attributeDefinitions[attrName] = attributeDefinition;
          lastProcessedAttributeDefinition = attributeDefinition;
        } else {
          attributeDefinition = lastProcessedAttributeDefinition;
        }
        this._attributeDefinition(row, attributeDefinition, attributeDefinition['type'], row['type']);
      }
      return attributeDefinitions;
    };


    /*
    Builds an attribute definition instance (called recursivly for each part in given raw type name ('set:<type>').
    @param {object} row The row object containing key/value pairs (header/value).
    @param {object} attributeDefinition The object containing attribute definition
    @param {object} type The attribute type instance.
    @param {string} rawTypeName The raw attribute type name (e.g. 'set:text')
     */

    ProductTypeGenerator.prototype._attributeDefinition = function(row, attributeDefinition, type, rawTypeName) {
      switch (type.name) {
        case ATTRIBUTE_TYPES.text:
        case ATTRIBUTE_TYPES.ltext:
          return attributeDefinition['inputHint'] = row['textInputHint'];
        case ATTRIBUTE_TYPES["enum"]:
          return type['values'] = (type['values'] || []).concat([
            {
              key: row['enumKey'].trim(),
              label: row[ATTRIBUTE_TYPES["enum"] + "Label"].trim()
            }
          ]);
        case ATTRIBUTE_TYPES.lenum:
          return type['values'] = (type['values'] || []).concat([
            {
              key: row['enumKey'].trim(),
              label: this._i18n(row, ATTRIBUTE_TYPES["enum"] + "Label")
            }
          ]);
        case ATTRIBUTE_TYPES.reference:
          if (row['type']) {
            return type['referenceTypeId'] = this._type(this._typeOrElementType(rawTypeName));
          }
          break;
        case ATTRIBUTE_TYPES.set:
          attributeDefinition['isRequired'] = false;
          attributeDefinition['isSearchable'] = false;
          if (row['type']) {
            type['elementType'] = {
              name: this._type(this._typeOrElementType(rawTypeName))
            };
          }
          return this._attributeDefinition(row, attributeDefinition, type['elementType'], this._typeOrElementType(rawTypeName));
        case ATTRIBUTE_TYPES.nested:
          return this._findProductTypeId(this._typeOrElementType(rawTypeName)).then(result)(function() {
            return type['typeReference'] = {
              id: result,
              typeId: "product-type"
            };
          });
      }
    };


    /**
     * Split the raw attribute type and return the attribute element type or the type itself
     * @param  {String} rawAttributeType The raw attribute type (e.g. 'text' or 'set:text')
     * @return {String} The mapped elements
     * @example
     *   'set:set:type' => 'set:type'
     *   'set:type'     => 'type'
     *   'text'         => 'text'
     */

    ProductTypeGenerator.prototype._typeOrElementType = function(rawAttributeType) {
      var parts;
      parts = rawAttributeType.split(':');
      if (parts.length !== 1) {
        parts = parts.slice(1);
      }
      return parts.join(':');
    };


    /**
     * Split the raw attribute type and return the first element, which is the real attribute type
     * @param  {String} rawAttributeType The raw attribute type (e.g. 'text' or 'set:text')
     * @return {String} The mapped elements types
     * @example
     *   'set:type' => 'set'
     *   'text'     => 'text'
     */

    ProductTypeGenerator.prototype._type = function(rawAttributeType) {
      return _.first(rawAttributeType.split(':'));
    };


    /**
     * Create an attribute definition 'masterSku' for master<->retailer support
     */

    ProductTypeGenerator.prototype._createAttributeDefinitionMastersku = function() {
      return {
        name: MASTER_SKU_NAME,
        label: {
          en: 'Master SKU'
        },
        type: {
          name: 'text'
        },
        attributeConstraint: 'Unique',
        isRequired: true,
        isSearchable: false,
        inputHint: 'SingleLine'
      };
    };


    /**
     * Map languages used for given attribute
     * @param  {String} name The name of the attribute header
     * @param  {Array} headers The list of headers from the CSV
     * @return {Array} The mapped list of languages
     */

    ProductTypeGenerator.prototype._languages = function(name, headers) {
      var header, i, languages, len, regexp, results;
      regexp = new RegExp("^" + name + "\.[a-zA-Z]{2}", 'i');
      languages = function(header) {
        var matched;
        matched = header.match(regexp);
        if (matched) {
          return _.last(matched[0].split("."));
        }
      };
      results = [];
      for (i = 0, len = headers.length; i < len; i++) {
        header = headers[i];
        if (header.match(regexp)) {
          results.push(languages(header));
        }
      }
      return results;
    };


    /**
     * Map key/value pairs for each language
     * @param  {Object} row The row containing key/value pairs (header/value)
     * @param  {String} header The attribute header
     * @return {Object} The mapped keys
     */

    ProductTypeGenerator.prototype._i18n = function(row, header) {
      var i, i18n, language, languages, len;
      i18n = {};
      languages = this._languages(header, _.keys(row));
      for (i = 0, len = languages.length; i < len; i++) {
        language = languages[i];
        i18n[language] = row[header + "." + language].trim();
      }
      return i18n;
    };


    /**
     * Create product-type definition objects
     * @param  {Array} types The parsed CSV records of product-types
     * @param  {Object} attributeDefinitions The mapped attribute definitions
     * @param  {Object} [defaultAttributeDefinition] Some attribute definitions added to the resulting product type definitions
     * @return {Array} The list of generated product-type definitions
     */

    ProductTypeGenerator.prototype._createProductTypesDefinitions = function(types, attributeDefinitions, defaultAttributeDefinition) {
      var attributeDefinition, header, i, len, productTypeDefinition, productTypeDefinitions, row, value;
      productTypeDefinitions = [];
      for (i = 0, len = types.length; i < len; i++) {
        row = types[i];
        productTypeDefinition = {
          name: row['name'],
          description: row['description'],
          attributes: []
        };
        for (header in row) {
          value = row[header];
          if (header === 'name' || header === 'description') {
            continue;
          }
          if (_.isString(value) && value.length > 0) {
            if (attributeDefinitions[header]) {
              attributeDefinition = attributeDefinitions[header];
              if (value.toLowerCase() !== 'x') {
                attributeDefinition.name = value;
              }
              productTypeDefinition.attributes.push(attributeDefinition);
            } else {
              console.log("[WARN] No attribute definition found with name '" + header + "', skipping...");
            }
          }
        }
        if (defaultAttributeDefinition) {
          productTypeDefinition.attributes.push(defaultAttributeDefinition);
        }
        productTypeDefinitions.push(productTypeDefinition);
      }
      return productTypeDefinitions;
    };

    ProductTypeGenerator.prototype._findProductTypeId = function(typeName) {
      console.log("trying to find product type with name " + typeName);
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.client.productTypes.where("name=" + typeName).fetch().then(result)(function() {
            console.log("got result: " + result);
            if (result.body.count === 0) {
              return reject("Didn't find any matching productType for name (" + typeName + ")");
            } else {
              if (_.size(result.body.results) > 1) {
                console.log("Found more than 1 " + typeName + ", will use the first one I found");
              }
              return resolve(result.body.results[0].id);
            }
          });
        };
      })(this));
    };

    return ProductTypeGenerator;

  })();

  module.exports = ProductTypeGenerator;

}).call(this);

//# sourceMappingURL=product-type-generator.js.map
